\documentclass[12pt]{article}
 
\usepackage[margin=1in]{geometry}
\usepackage{amsmath,amsthm,amssymb}

\newcommand{\N}{\mathbb{N}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
 
\newenvironment{theorem}[2][Theorem]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{lemma}[2][Lemma]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{exercise}[2][Exercise]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{problem}[2][Problem]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{question}[2][Question]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{corollary}[2][Corollary]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
 
\begin{document}
 
\title{Lab 1: C System Programming Review}
\author{ 
CS536 \\ Duc Viet Le}
\maketitle
\begin{problem}{1}\
	\begin{enumerate} 
		\item What happens if the return value of \texttt{execlp()} is not checked and you give an invalid command, say, \texttt{lssss}, as input to the shell?\\ 
		\textbf{Ans.} if \texttt{execlp()} is not checked,  if an invalid command is passed to the shell, the child process will not be terminated, and the code will create a new child process to handle next user input.
		\item What happens if the parent process does not perform \texttt{waitpid()} and immediately returns to the beginning of the \texttt{while-loop}? \\ 
		\textbf{Ans.} Even when a child exits, the Linux system will still keeps some information of child processes. The parent is required to clean up child processes (i.e using \texttt{waitpid()}). \\
		If the parent process does not perform \texttt{waitpid()}, its child processes are still there and do nothing (i.e becoming zoombies). They waste memory and may cause the kernel to run out of processes.
		\item If the concurrent server were a file server that receives client requests from processes on the same host/OS (or over a network), why is performing \texttt{waitpid()} as a blocking call from within the parent process not a valid approach? Describe an asynchronous method for performing \texttt{waitpid()} so child processes are prevented from becoming zombies and their exit status can be checked. \\
		\textbf{Ans.}   
		\item Ignoring the functional simplifications of the shell code, point out at least two programming bugs that should be fixed to yield more reliable server code.\\
		\textbf{Ans.}
		\begin{itemize}
			\item Did not check if \texttt{k < 0}, when the code fails to create child process (i.e fail to \texttt{fork()})
			\item 
		\end{itemize}
	\end{enumerate}
\end{problem}
\end{document}
